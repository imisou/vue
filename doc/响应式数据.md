# Vue中的双向绑定过程

### 问题：

### 参考

### 

首先我们先想这么一个问题，Vue的响应式数据的作用是什么。我们在每一次修改data|computed的数据的时候，都会影响View的结果。同时如果我们没有在 render中使用这个属性，那么我们修改这个属性的时候，render就不会触发从而更新视图。那么这样想起来 在发布-订阅者模式中 我们每一个属性都应该是一个发布者，而不是整个data属性是一个发布者。

#### 发布-订阅者模式

对于一个发布者来说 其需要的是哪些核心功能：

1. 有一个属性能够保存订阅了其的订阅者数据

2. 能够提供 添加、删除订阅者的功能

3. 提供通知其所有订阅者数据更新的功能

对于一个订阅者来说，其需要的是：

1. 能够接受发布者提供的数据更新功能

这时候我们去简单实现一个发布订阅者

```js
var uid = 1;
class Dep {
    subs = [];
    name = '';
    constructor(name){
        this.uid = ++uid;
        this.name = name;
        // 初始化 一个存储其 订阅者数据
        this.subs = [];
    }
    // 添加订阅者
    addDep(watcher){
        this.subs.push(watcher);
    }
    // 删除订阅者
    removeDep(watcher){
        this.subs.splice(this.subs.indexOf(watcher) ,1);
    }
    // 通知订阅者
    notify(){
        this.subs.forEach(watcher => {
            watcher.update(this);
        })
    }
}
class Watcher {
    name = '';
    constructor(name){
        this.name = name;
    }
    update(dep){
        //
        console.log(`${dep.name}有消息了:${this.name}请接收`)
    }
}
var baoshe1 = new Dep('报社1');
var baoshe2 = new Dep('报社2');
var yonghu1 = new Watcher('用户1');
var yonghu2 = new Watcher('用户2');
var yonghu3 = new Watcher('用户3');

baoshe1.addDep(yonghu1);
baoshe1.addDep(yonghu2);
baoshe2.addDep(yonghu3);
baoshe1.notify();
baoshe2.notify();
```

这时候我们发现一个问题：

1. **我们需要发布者去添加订阅者，而不是订阅者去订阅发布者**,对于Vue来说，其在 initState的时候为每一个属性生成一个发布者实例，那么在render的时候如何知道 我这个订阅者订阅了哪一个发布者？

这时候就需要 Object.defineProperty('','',{ get, set}) 这个方法， 我们看

```js
/**
 * Define a reactive property on an Object.
 * 将data|props|computed中的某一个属性借助Object.defineProperty()变成响应式
 */
export function defineReactive(
    obj: Object,   // 处理的是哪一个对象
    key: string,   // 处理的是obj 上的哪一个属性
    val: any,      // 其初始值
    customSetter ? : ? Function,
    shallow ? : boolean    // 是否判断子属性是否为对象，false则判断
) {
    // 定义一个发布者实例
    // 使得每一个属性 都变成一个发布者 那么此属性修改了就可以通过dep.notify去通知其订阅者
    const dep = new Dep()

    // 获取data上此属性的属性描述对象
    const property = Object.getOwnPropertyDescriptor(obj, key)
    if (property && property.configurable === false) {
        return
    }

    // cater for pre-defined getter/setters
    // 缓存原来此属性上的 get/set方法
    const getter = property && property.get
    const setter = property && property.set
    if ((!getter || setter) && arguments.length === 2) {
        val = obj[key]
    }
    
    // 如果此属性还是对象继续向下遍历 
    let childOb = !shallow && observe(val)
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        // 依赖收集
        // 记得我们 如果 访问 this.name.obj.xx 其会依次触发 this.name的get 然后this.name.obj的get ..
        get: function reactiveGetter() {
            const value = getter ? getter.call(obj) : val
            // 在我们 mountComponent的时候 我们 new Watcher() 
            // 此时  调用了pushTarget 使得当前 Dep的静态属性 target指向 组件的 _watcher 对象
            // 那么我们在 render() 函数 转 vnode 时候 访问 某一个属性的时候就会触发此属性的
            // get 方法
            // 
            // 此时 Dep.target 指向 正在处理的组件实例的 _watcher 对象
            if (Dep.target) {
                // 调用每一个属性上的 dep实例
                dep.depend()
                // TODO: 为什么需要 childOb
                if (childOb) {
                    childOb.dep.depend()
                    if (Array.isArray(value)) {
                        dependArray(value)
                    }
                }
            }
            return value
        },
        // 派发更新
        // 当我们 在代码中使用 this.dataKey = '12312';将触发dataKey的set方法
        set: function reactiveSetter(newVal) {
            //如果我们在data的时候定义了 此属性的getter方法  那么我们就需要执行getter方法获取正确的新值
            const value = getter ? getter.call(obj) : val
            /* eslint-disable no-self-compare */
            // 如果 新值与旧值相同  就不处理了
            if (newVal === value || (newVal !== newVal && value !== value)) {
                return
            }
            /* eslint-enable no-self-compare */
            if (process.env.NODE_ENV !== 'production' && customSetter) {
                // 定义了公共的setter方法
                customSetter()
            }
            // 定义了setter方法  那么就需要调用一下setter方法
            if (setter) {
                setter.call(obj, newVal)
            } else {
                val = newVal
            }
            childOb = !shallow && observe(newVal)
            // 通知订阅者更新
            dep.notify()
        }
    })
}

```
从上面的代码可以看出，其在处理每一个响应式属性的时候，都申明了一个  const dep = new Dep() （闭包），然后修改了其 get set方法， 那么在组件render的时候其会调用此属性的时候 就会触发此属性的 get 方法

```js
get: function reactiveGetter() {
   // 调用属性自定义的 getter方法  或者 没有设置 get 就返回val 
    const value = getter ? getter.call(obj) : val

    // 这时候就是 订阅者 将自身订阅到发布者的过程
    if (Dep.target) {
        // 调用每一个属性上的 dep实例
        dep.depend()
        // TODO: 为什么需要 childOb
        if (childOb) {
            childOb.dep.depend()
            if (Array.isArray(value)) {
                dependArray(value)
            }
        }
    }
    return value
},
```

在get中我们根据闭包的原理，这时候我们可以通过 dep 获取到属性发布者实例对象，但是如何获取到当前的 订阅者实例对象哪？

这时候 Dep.target 的作用就出来了。我们再看 订阅者实例初始化的时候执行 get()方法，这时候会执行  pushTarget(this)

```js
get() {
    pushTarget(this)
}
```
这时候我们再看

```js
// 存储了当前处理的watcher 对象
Dep.target = null;
// 当我们处理父子组件的时候 我们先执行 父组件的mountComponent()  此时Dep.target = 父watcher
// 然后执行到子组件 此时 Dep.target 存在 先将其存放在targetStack栈中，
// 然后发现没有子组件了 popTarget()从栈中获取当前的target
const targetStack = [];

export function pushTarget(_target: ?Watcher) {
	if (Dep.target) targetStack.push(Dep.target);
	Dep.target = _target;
}

export function popTarget() {
	Dep.target = targetStack.pop();
}
```
Dep.target 是Dep的一个静态属性，是所有实例对象共享的。那么在new Watcher的时候 就可以通过 get 方法的 pushTarget方法将当前处理的 Watcher 实例对象 保存到 Dep.target。

那么这时候我们再看上面的响应式数据的 get 方法我们就知道 dep 代表的当前发布者实例对象、 Dep.target 代表当前的订阅者Watcher实例对象。

我们再看 dep.depend() 

```js
depend() {
	// Dep.target 指向的是 组件vm._watcher 对象
	if (Dep.target) {
		// 调用Watcher 的addDep方法
		// this 指向  每一个属性 闭包保存的dep实例
		Dep.target.addDep(this);
	}
}
```
这时候的 this -> dep   Dep.taregt -> watcher

```js
// 发布者  添加一个订阅者(这里就是 Watcher)
addSub(sub: Watcher) {
	this.subs.push(sub);
}
```
那么这时候我们就把 订阅者 存放到其订阅的发布者对象的 subs属性下了。

#### 响应式数据更新如何影响到 Watcher

我们再看响应式数据绑定的时候的 set方法

```js
Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,

    // 派发更新
    // 当我们 在代码中使用 this.dataKey = '12312';将触发dataKey的set方法
    set: function reactiveSetter(newVal) {
        //如果我们在data的时候定义了 此属性的getter方法  那么我们就需要执行getter方法获取正确的新值
        const value = getter ? getter.call(obj) : val
        /* eslint-disable no-self-compare */
        // 如果 新值与旧值相同  就不处理了
        if (newVal === value || (newVal !== newVal && value !== value)) {
            return
        }
        /* eslint-enable no-self-compare */
        if (process.env.NODE_ENV !== 'production' && customSetter) {
            // 定义了公共的setter方法
            customSetter()
        }
        // 定义了setter方法  那么就需要调用一下setter方法
        if (setter) {
            setter.call(obj, newVal)
        } else {
            val = newVal
        }
        childOb = !shallow && observe(newVal)
        // 通知订阅者更新
        dep.notify()
    }
})
```

其最重要的还是 dep.notify() 方法

```js
// 提供发布者通知订阅者更新的方法
notify() {
	// 浅拷贝一份当前订阅了当前发布者的所有订阅者数据
	const subs = this.subs.slice();
	for (let i = 0, l = subs.length; i < l; i++) {
		// 调用每一个订阅者update方法  其实就是watcher的update方法
		subs[i].update();
	}
}
```
调用每一个订阅者的 update 方法
